<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DAProj2: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DAProj2
   </div>
   <div id="projectbrief">This is a project to analyse the use of different approaches for the TSP problem</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents a graph.  
 <a href="class_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_graph_8h_source.html">Graph.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memItemLeft" align="right" valign="top"><a id="ae4c72b8ac4d693c49800a4c7e273654f" name="ae4c72b8ac4d693c49800a4c7e273654f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Graph</b> ()</td></tr>
<tr class="memdesc:ae4c72b8ac4d693c49800a4c7e273654f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for the <a class="el" href="class_graph.html" title="Represents a graph.">Graph</a> class. <br /></td></tr>
<tr class="separator:ae4c72b8ac4d693c49800a4c7e273654f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b14c9bc0b5fbf50165aaf92f4aeef1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a7b14c9bc0b5fbf50165aaf92f4aeef1d">Graph</a> (int n)</td></tr>
<tr class="memdesc:a7b14c9bc0b5fbf50165aaf92f4aeef1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized constructor for the <a class="el" href="class_graph.html" title="Represents a graph.">Graph</a> class.  <br /></td></tr>
<tr class="separator:a7b14c9bc0b5fbf50165aaf92f4aeef1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6795bc8951d6127463b7acc861fe25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acf6795bc8951d6127463b7acc861fe25">Graph</a> (vector&lt; <a class="el" href="structnode.html">node</a> &gt; <a class="el" href="class_graph.html#aa5a56df7d8b0a08b6def3c21d4308577">nodes</a>)</td></tr>
<tr class="memdesc:acf6795bc8951d6127463b7acc861fe25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameterized constructor for the <a class="el" href="class_graph.html" title="Represents a graph.">Graph</a> class.  <br /></td></tr>
<tr class="separator:acf6795bc8951d6127463b7acc861fe25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12189252977811dcb0912695f2df931"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structnode.html">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ad12189252977811dcb0912695f2df931">getNodes</a> ()</td></tr>
<tr class="memdesc:ad12189252977811dcb0912695f2df931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the nodes in the graph.  <br /></td></tr>
<tr class="separator:ad12189252977811dcb0912695f2df931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f9107e20da8671d074b15309e9a20f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a90f9107e20da8671d074b15309e9a20f">tspBT</a> (unsigned int n, unsigned int path[])</td></tr>
<tr class="memdesc:a90f9107e20da8671d074b15309e9a20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem using the backtracking approach.  <br /></td></tr>
<tr class="separator:a90f9107e20da8671d074b15309e9a20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807d3fac7b54b21b0db93e27d827f23c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a807d3fac7b54b21b0db93e27d827f23c">tspBTRec</a> (unsigned int n, unsigned int curIndex, unsigned int curDist, unsigned int curPath[], unsigned int &amp;minDist, unsigned int path[])</td></tr>
<tr class="memdesc:a807d3fac7b54b21b0db93e27d827f23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive function for the backtracking approach to solve the Traveling Salesman Problem.  <br /></td></tr>
<tr class="separator:a807d3fac7b54b21b0db93e27d827f23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b458d66099641cf4519e4fa7b8277a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3b458d66099641cf4519e4fa7b8277a1">addEdge</a> (int source, int dest, double weight)</td></tr>
<tr class="memdesc:a3b458d66099641cf4519e4fa7b8277a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge to the graph.  <br /></td></tr>
<tr class="separator:a3b458d66099641cf4519e4fa7b8277a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442deae8d93a0f59de6501796d3925b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a442deae8d93a0f59de6501796d3925b0">addNode</a> (const <a class="el" href="structnode.html">node</a> &amp;n)</td></tr>
<tr class="memdesc:a442deae8d93a0f59de6501796d3925b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the graph.  <br /></td></tr>
<tr class="separator:a442deae8d93a0f59de6501796d3925b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505398787c7e3ebc07c1e4c1907e3411"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a505398787c7e3ebc07c1e4c1907e3411">addPerfectMatching</a> (vector&lt; <a class="el" href="structedge.html">edge</a> &gt; edges)</td></tr>
<tr class="memdesc:a505398787c7e3ebc07c1e4c1907e3411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a perfect matching to the graph.  <br /></td></tr>
<tr class="separator:a505398787c7e3ebc07c1e4c1907e3411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f98e986cbf51cf28d6db3664dfbc48"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a69f98e986cbf51cf28d6db3664dfbc48">eulerianCycle</a> ()</td></tr>
<tr class="memdesc:a69f98e986cbf51cf28d6db3664dfbc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an Eulerian cycle in the graph.  <br /></td></tr>
<tr class="separator:a69f98e986cbf51cf28d6db3664dfbc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc6c0e5211c93d54a3c4f8c11508a2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a3bc6c0e5211c93d54a3c4f8c11508a2e">getAugmentingPath</a> (int s)</td></tr>
<tr class="memdesc:a3bc6c0e5211c93d54a3c4f8c11508a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an augmenting path in the graph using the Blossom Algorithm.  <br /></td></tr>
<tr class="separator:a3bc6c0e5211c93d54a3c4f8c11508a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc5fb36496fc9a38efe656fa4a39bcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a8bc5fb36496fc9a38efe656fa4a39bcf">reset_values</a> ()</td></tr>
<tr class="memdesc:a8bc5fb36496fc9a38efe656fa4a39bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the values of the nodes in the graph.  <br /></td></tr>
<tr class="separator:a8bc5fb36496fc9a38efe656fa4a39bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca4e47f47d10c21d871be0307173593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0ca4e47f47d10c21d871be0307173593">reset_visited</a> ()</td></tr>
<tr class="memdesc:a0ca4e47f47d10c21d871be0307173593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the visited flag and parent of the nodes in the graph.  <br /></td></tr>
<tr class="separator:a0ca4e47f47d10c21d871be0307173593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a92d74e5ef7c79ddabb6c357949c49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a48a92d74e5ef7c79ddabb6c357949c49">makeMSTGraph</a> (const vector&lt; <a class="el" href="structedge.html">edge</a> &gt; &amp;mst) const</td></tr>
<tr class="memdesc:a48a92d74e5ef7c79ddabb6c357949c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new graph from a minimum spanning tree.  <br /></td></tr>
<tr class="separator:a48a92d74e5ef7c79ddabb6c357949c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd27f6c402d190f0d46945ec6e71f152"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#abd27f6c402d190f0d46945ec6e71f152">blossomMark</a> (int lca, int s)</td></tr>
<tr class="memdesc:abd27f6c402d190f0d46945ec6e71f152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks nodes in a blossom during the Blossom Algorithm.  <br /></td></tr>
<tr class="separator:abd27f6c402d190f0d46945ec6e71f152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a78ccd847b4cbd8b62de4b6dde60e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a70a78ccd847b4cbd8b62de4b6dde60e2">blossomContract</a> (int s, int u, int v, queue&lt; int &gt; &amp;q)</td></tr>
<tr class="memdesc:a70a78ccd847b4cbd8b62de4b6dde60e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contracts a blossom during the Blossom Algorithm.  <br /></td></tr>
<tr class="separator:a70a78ccd847b4cbd8b62de4b6dde60e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc921d9884b7a90038191f448d31cd43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#afc921d9884b7a90038191f448d31cd43">findCA</a> (int root, int u, int v)</td></tr>
<tr class="memdesc:afc921d9884b7a90038191f448d31cd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the lowest common ancestor of two nodes.  <br /></td></tr>
<tr class="separator:afc921d9884b7a90038191f448d31cd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3484ed1d56caf2ba257dfe7f568638e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structedge.html">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa3484ed1d56caf2ba257dfe7f568638e">mstPrim</a> ()</td></tr>
<tr class="memdesc:aa3484ed1d56caf2ba257dfe7f568638e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a minimum spanning tree using Prim's algorithm.  <br /></td></tr>
<tr class="separator:aa3484ed1d56caf2ba257dfe7f568638e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c82196895d2cef983954dfb74617eba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0c82196895d2cef983954dfb74617eba">changePairs</a> (int v)</td></tr>
<tr class="memdesc:a0c82196895d2cef983954dfb74617eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the pairs of nodes during the Blossom Algorithm.  <br /></td></tr>
<tr class="separator:a0c82196895d2cef983954dfb74617eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36acdcc43a0592170316c4b583091471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a36acdcc43a0592170316c4b583091471">oddDegree</a> (const vector&lt; <a class="el" href="structnode.html">node</a> &gt; &amp;nods)</td></tr>
<tr class="memdesc:a36acdcc43a0592170316c4b583091471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies nodes with odd degrees in the graph.  <br /></td></tr>
<tr class="separator:a36acdcc43a0592170316c4b583091471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49afc00278eb4dee72ce470bacd4522"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structedge.html">edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab49afc00278eb4dee72ce470bacd4522">BlossomAlgorithm</a> (vector&lt; <a class="el" href="structedge.html">edge</a> &gt; mst)</td></tr>
<tr class="memdesc:ab49afc00278eb4dee72ce470bacd4522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Blossom Algorithm.  <br /></td></tr>
<tr class="separator:ab49afc00278eb4dee72ce470bacd4522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b4a3e9504dc9a715e27762504768a2"><td class="memItemLeft" align="right" valign="top">vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a43b4a3e9504dc9a715e27762504768a2">ChristofidesAlgorithm</a> ()</td></tr>
<tr class="memdesc:a43b4a3e9504dc9a715e27762504768a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the Christofides Algorithm to find an approximate solution to the Traveling Salesman Problem.  <br /></td></tr>
<tr class="separator:a43b4a3e9504dc9a715e27762504768a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0599c99a927159e454a5b3ded58ca54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ab0599c99a927159e454a5b3ded58ca54">tspApproximation</a> ()</td></tr>
<tr class="memdesc:ab0599c99a927159e454a5b3ded58ca54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the Traveling Salesman Problem using Triangular Approximation algorithm.  <br /></td></tr>
<tr class="separator:ab0599c99a927159e454a5b3ded58ca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc42aaed8e8653052598c5410c80033"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adcc42aaed8e8653052598c5410c80033">getDistance</a> (const <a class="el" href="structnode.html">node</a> &amp;node1, const <a class="el" href="structnode.html">node</a> &amp;node2)</td></tr>
<tr class="memdesc:adcc42aaed8e8653052598c5410c80033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Haversine distance between two nodes.  <br /></td></tr>
<tr class="separator:adcc42aaed8e8653052598c5410c80033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29731639465cab257e3d0d341e8756f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a29731639465cab257e3d0d341e8756f7">adjustGraph</a> (bool toComplete)</td></tr>
<tr class="memdesc:a29731639465cab257e3d0d341e8756f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts the graph so that it respects the triangular inequality rule.  <br /></td></tr>
<tr class="separator:a29731639465cab257e3d0d341e8756f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa5a56df7d8b0a08b6def3c21d4308577"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structnode.html">node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aa5a56df7d8b0a08b6def3c21d4308577">nodes</a></td></tr>
<tr class="separator:aa5a56df7d8b0a08b6def3c21d4308577"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a graph. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7b14c9bc0b5fbf50165aaf92f4aeef1d" name="a7b14c9bc0b5fbf50165aaf92f4aeef1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b14c9bc0b5fbf50165aaf92f4aeef1d">&#9670;&#160;</a></span>Graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameterized constructor for the <a class="el" href="class_graph.html" title="Represents a graph.">Graph</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf6795bc8951d6127463b7acc861fe25" name="acf6795bc8951d6127463b7acc861fe25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6795bc8951d6127463b7acc861fe25">&#9670;&#160;</a></span>Graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Graph::Graph </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structnode.html">node</a> &gt;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameterized constructor for the <a class="el" href="class_graph.html" title="Represents a graph.">Graph</a> class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodes</td><td>The nodes in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3b458d66099641cf4519e4fa7b8277a1" name="a3b458d66099641cf4519e4fa7b8277a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b458d66099641cf4519e4fa7b8277a1">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an edge to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source node of the edge. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination node of the edge. </td></tr>
    <tr><td class="paramname">weight</td><td>The weight of the edge.</td></tr>
    <tr><td class="paramname">source</td><td>The source node ID of the edge. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination node ID of the edge. </td></tr>
    <tr><td class="paramname">weight</td><td>The weight/cost of the edge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a442deae8d93a0f59de6501796d3925b0" name="a442deae8d93a0f59de6501796d3925b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442deae8d93a0f59de6501796d3925b0">&#9670;&#160;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnode.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a node to the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The node to add.</td></tr>
    <tr><td class="paramname">n</td><td>The node to be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a505398787c7e3ebc07c1e4c1907e3411" name="a505398787c7e3ebc07c1e4c1907e3411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505398787c7e3ebc07c1e4c1907e3411">&#9670;&#160;</a></span>addPerfectMatching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::addPerfectMatching </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structedge.html">edge</a> &gt;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a perfect matching to the graph. </p>
<p>Adds the edges of a perfect matching to the graph. This function adds the edges of a perfect matching to the graph. The edges are provided as a vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edges</td><td>The edges representing the perfect matching.</td></tr>
    <tr><td class="paramname">edges</td><td>The edges of the perfect matching to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29731639465cab257e3d0d341e8756f7" name="a29731639465cab257e3d0d341e8756f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29731639465cab257e3d0d341e8756f7">&#9670;&#160;</a></span>adjustGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::adjustGraph </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toComplete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjusts the graph so that it respects the triangular inequality rule. </p>
<p>This function adjusts the graph edges so that the triangular inequality is met. The function iterates through the existing edges and checks if, in a pair of three vertexes (A, B and C), the weights of the edges that connect them follow the rule of Weight(A-&gt;B) + Weight(B-&gt;C) &gt;= Weight(A-&gt;C).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toComplete</td><td>flag to know if the graph should be completed or just adjusted</td></tr>
    <tr><td class="paramname">toComplete</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab49afc00278eb4dee72ce470bacd4522" name="ab49afc00278eb4dee72ce470bacd4522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49afc00278eb4dee72ce470bacd4522">&#9670;&#160;</a></span>BlossomAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structedge.html">edge</a> &gt; Graph::BlossomAlgorithm </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structedge.html">edge</a> &gt;&#160;</td>
          <td class="paramname"><em>mst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Blossom Algorithm. </p>
<p>Finds the minimum weight matching of odd-degree nodes using the Blossom algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td>The minimum spanning tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The edges of the perfect matching.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td>A minimum spanning tree of the graph. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of edges representing the minimum weight matching. </dd></dl>

</div>
</div>
<a id="a70a78ccd847b4cbd8b62de4b6dde60e2" name="a70a78ccd847b4cbd8b62de4b6dde60e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a78ccd847b4cbd8b62de4b6dde60e2">&#9670;&#160;</a></span>blossomContract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::blossomContract </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">queue&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contracts a blossom during the Blossom Algorithm. </p>
<p>Contracts a blossom. This function contracts a blossom in the graph. It marks the nodes in the blossom, updates the parent pointers, and assigns the base node for each node in the blossom. It also adds the newly contracted nodes to the BFS queue for further exploration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The starting node. </td></tr>
    <tr><td class="paramname">u</td><td>The first node of the blossom. </td></tr>
    <tr><td class="paramname">v</td><td>The second node of the blossom. </td></tr>
    <tr><td class="paramname">q</td><td>The queue of unvisited nodes.</td></tr>
    <tr><td class="paramname">s</td><td>The source node of the current augmenting path. </td></tr>
    <tr><td class="paramname">u</td><td>The first node of the blossom. </td></tr>
    <tr><td class="paramname">v</td><td>The second node of the blossom. </td></tr>
    <tr><td class="paramname">q</td><td>The queue of unvisited nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd27f6c402d190f0d46945ec6e71f152" name="abd27f6c402d190f0d46945ec6e71f152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd27f6c402d190f0d46945ec6e71f152">&#9670;&#160;</a></span>blossomMark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::blossomMark </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lca</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks nodes in a blossom during the Blossom Algorithm. </p>
<p>Marks the nodes in a blossom. This function marks the nodes in a blossom starting from the given LCA (lowest common ancestor) and going up to the current node. It sets the isInBlossom flag to true for each node in the blossom. It also updates the parent pointer for the current node if it is not the LCA.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lca</td><td>The lowest common ancestor node. </td></tr>
    <tr><td class="paramname">s</td><td>The starting node.</td></tr>
    <tr><td class="paramname">lca</td><td>The lowest common ancestor of the blossom. </td></tr>
    <tr><td class="paramname">s</td><td>The current node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c82196895d2cef983954dfb74617eba" name="a0c82196895d2cef983954dfb74617eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c82196895d2cef983954dfb74617eba">&#9670;&#160;</a></span>changePairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::changePairs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the pairs of nodes during the Blossom Algorithm. </p>
<p>Changes the pairs in the augmenting path. This function changes the pairs in the augmenting path found by getAugmentingPath. It iterates through the path, updating the pair and paired flags for each node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The starting node.</td></tr>
    <tr><td class="paramname">v</td><td>The node where the augmenting path ends. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43b4a3e9504dc9a715e27762504768a2" name="a43b4a3e9504dc9a715e27762504768a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b4a3e9504dc9a715e27762504768a2">&#9670;&#160;</a></span>ChristofidesAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::ChristofidesAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the Christofides Algorithm to find an approximate solution to the Traveling Salesman Problem. </p>
<p>Implements the Christofides' algorithm to find an approximate solution to the Traveling Salesman Problem. This function implements the Christofides' algorithm to find an approximate solution to the Traveling Salesman Problem. It first resets the values of all nodes in the graph. Then, it performs Prim's algorithm to find the minimum spanning tree (MST) of the graph and creates a new graph with the MST edges. It identifies nodes with odd degrees in the new graph and applies the Blossom algorithm to find a perfect matching. The perfect matching edges are added to the new graph, and an Eulerian cycle is found. Finally, an Hamiltoninan circuit is returned as the approximate solution to the TSP.</p>
<dl class="section return"><dt>Returns</dt><dd>The approximate solution.</dd>
<dd>
The approximate solution to the Traveling Salesman Problem. </dd></dl>

</div>
</div>
<a id="a69f98e986cbf51cf28d6db3664dfbc48" name="a69f98e986cbf51cf28d6db3664dfbc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f98e986cbf51cf28d6db3664dfbc48">&#9670;&#160;</a></span>eulerianCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; int &gt; Graph::eulerianCycle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an Eulerian cycle in the graph. </p>
<p>Finds an Eulerian cycle in the graph and then a Hamiltonian circuit. This function finds an Eulerian cycle in the graph using the Hierholzer's algorithm. It starts from a given node, explores all edges in a depth-first manner, and returns the Eulerian cycle as a vector of node IDs. Then, it cleans the repeated vertexes and finds a Hamiltonian circuit.</p>
<dl class="section return"><dt>Returns</dt><dd>The nodes in the Eulerian cycle.</dd>
<dd>
The Eulerian cycle in the graph. </dd></dl>

</div>
</div>
<a id="afc921d9884b7a90038191f448d31cd43" name="afc921d9884b7a90038191f448d31cd43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc921d9884b7a90038191f448d31cd43">&#9670;&#160;</a></span>findCA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::findCA </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the lowest common ancestor of two nodes. </p>
<p>Finds the lowest common ancestor (LCA) of two nodes in the contracted graph. This function finds the lowest common ancestor of two nodes in the contracted graph using the base and pair information stored in the nodes. It starts from the given root node and iteratively follows the parent and base pointers until it reaches the root node again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The root node. </td></tr>
    <tr><td class="paramname">u</td><td>The first node. </td></tr>
    <tr><td class="paramname">v</td><td>The second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowest common ancestor.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The root node of the contracted graph. </td></tr>
    <tr><td class="paramname">u</td><td>The first node. </td></tr>
    <tr><td class="paramname">v</td><td>The second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lowest common ancestor of the two nodes in the contracted graph. </dd></dl>

</div>
</div>
<a id="a3bc6c0e5211c93d54a3c4f8c11508a2e" name="a3bc6c0e5211c93d54a3c4f8c11508a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc6c0e5211c93d54a3c4f8c11508a2e">&#9670;&#160;</a></span>getAugmentingPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::getAugmentingPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an augmenting path in the graph using the Blossom Algorithm. </p>
<p>Finds an augmenting path starting from the given source node. This function performs a BFS search to find an augmenting path in the graph starting from the given source node. It explores the graph by following the edges and updates the parent pointers for each visited node. If an augmenting path is found, it returns the node where the path ends.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The starting node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The destination node of the augmenting path, or -1 if no augmenting path is found.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The node where the augmenting path ends, or -1 if no augmenting path is found. </dd></dl>

</div>
</div>
<a id="adcc42aaed8e8653052598c5410c80033" name="adcc42aaed8e8653052598c5410c80033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc42aaed8e8653052598c5410c80033">&#9670;&#160;</a></span>getDistance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Graph::getDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structnode.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structnode.html">node</a> &amp;&#160;</td>
          <td class="paramname"><em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Haversine distance between two nodes. </p>
<p>Calculates the distance between two nodes using the Haversine formula. The Haversine formula is used to compute the great-circle distance between two points on a sphere (e.g., Earth) given their latitude and longitude coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The first node. </td></tr>
    <tr><td class="paramname">node2</td><td>The second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Haversine distance between the nodes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node1</td><td>The first node. </td></tr>
    <tr><td class="paramname">node2</td><td>The second node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the two nodes in the same unit as the Earth's radius. </dd></dl>

</div>
</div>
<a id="ad12189252977811dcb0912695f2df931" name="ad12189252977811dcb0912695f2df931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12189252977811dcb0912695f2df931">&#9670;&#160;</a></span>getNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structnode.html">node</a> &gt; Graph::getNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the nodes in the graph. </p>
<p>Gets all the nodes in the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>The nodes in the graph.</dd>
<dd>
A vector of nodes in the graph. </dd></dl>

</div>
</div>
<a id="a48a92d74e5ef7c79ddabb6c357949c49" name="a48a92d74e5ef7c79ddabb6c357949c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a92d74e5ef7c79ddabb6c357949c49">&#9670;&#160;</a></span>makeMSTGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::makeMSTGraph </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structedge.html">edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new graph from a minimum spanning tree. </p>
<p>Creates a new graph with the given edges as the minimum spanning tree. This function creates a new graph with the given edges as the minimum spanning tree. It copies the nodes from the current graph and adds the edges of the MST to the new graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td>The minimum spanning tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new graph.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mst</td><td>The edges of the minimum spanning tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new graph with the given MST edges. </dd></dl>

</div>
</div>
<a id="aa3484ed1d56caf2ba257dfe7f568638e" name="aa3484ed1d56caf2ba257dfe7f568638e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3484ed1d56caf2ba257dfe7f568638e">&#9670;&#160;</a></span>mstPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structedge.html">edge</a> &gt; Graph::mstPrim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a minimum spanning tree using Prim's algorithm. </p>
<p>Performs Prim's algorithm to find the minimum spanning tree (MST) of the graph. This function uses Prim's algorithm to find the MST of the graph. It starts from node 0 as the initial node, maintains a priority queue of edges, and keeps track of the parent and distance of each node. It returns the edges of the MST.</p>
<dl class="section return"><dt>Returns</dt><dd>The edges of the minimum spanning tree. </dd></dl>

</div>
</div>
<a id="a36acdcc43a0592170316c4b583091471" name="a36acdcc43a0592170316c4b583091471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36acdcc43a0592170316c4b583091471">&#9670;&#160;</a></span>oddDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::oddDegree </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structnode.html">node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nods</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Identifies nodes with odd degrees in the graph. </p>
<p>Determines if each node in the given vector has an odd number of edges. This function checks if each node in the given vector has an odd number of edges. If a node has an odd number of edges, its "isOdd" flag is set to true in the current graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nods</td><td>The nodes in the graph.</td></tr>
    <tr><td class="paramname">nods</td><td>The vector of nodes to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bc5fb36496fc9a38efe656fa4a39bcf" name="a8bc5fb36496fc9a38efe656fa4a39bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc5fb36496fc9a38efe656fa4a39bcf">&#9670;&#160;</a></span>reset_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::reset_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the values of the nodes in the graph. </p>
<p>Resets the values of all nodes in the graph. This function resets the visited, isInBlossom, paired, pair, base, and parent values of all nodes in the graph. </p>

</div>
</div>
<a id="a0ca4e47f47d10c21d871be0307173593" name="a0ca4e47f47d10c21d871be0307173593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca4e47f47d10c21d871be0307173593">&#9670;&#160;</a></span>reset_visited()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::reset_visited </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the visited flag and parent of the nodes in the graph. </p>
<p>Resets the visited, parent, and base values of all nodes in the graph. </p>

</div>
</div>
<a id="ab0599c99a927159e454a5b3ded58ca54" name="ab0599c99a927159e454a5b3ded58ca54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0599c99a927159e454a5b3ded58ca54">&#9670;&#160;</a></span>tspApproximation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tspApproximation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem using Triangular Approximation algorithm. </p>
<p>Approximates the Travelling Salesman Problem (TSP) using a heuristic algorithm. </p>

</div>
</div>
<a id="a90f9107e20da8671d074b15309e9a20f" name="a90f9107e20da8671d074b15309e9a20f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f9107e20da8671d074b15309e9a20f">&#9670;&#160;</a></span>tspBT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Graph::tspBT </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>path</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the Traveling Salesman Problem using the backtracking approach. </p>
<p>Finds the minimum distance Hamiltonian path using backtracking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes. </td></tr>
    <tr><td class="paramname">path</td><td>The array to store the path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the shortest path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">path</td><td>An array to store the best path found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minimum distance of the Hamiltonian path. </dd></dl>

</div>
</div>
<a id="a807d3fac7b54b21b0db93e27d827f23c" name="a807d3fac7b54b21b0db93e27d827f23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807d3fac7b54b21b0db93e27d827f23c">&#9670;&#160;</a></span>tspBTRec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::tspBTRec </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>curPath</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&#160;</td>
          <td class="paramname"><em>minDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>path</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive function for the backtracking approach to solve the Traveling Salesman Problem. </p>
<p>Solves the Traveling Salesman Problem (TSP) using backtracking. This function recursively finds the shortest Hamiltonian cycle (closed path) in a graph by exploring all possible paths and backtracking when a path becomes longer than the current minimum distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of nodes. </td></tr>
    <tr><td class="paramname">curIndex</td><td>The current index in the path. </td></tr>
    <tr><td class="paramname">curDist</td><td>The current distance. </td></tr>
    <tr><td class="paramname">curPath</td><td>The current path. </td></tr>
    <tr><td class="paramname">minDist</td><td>The minimum distance. </td></tr>
    <tr><td class="paramname">path</td><td>The array to store the path.</td></tr>
    <tr><td class="paramname">n</td><td>The number of nodes in the graph. </td></tr>
    <tr><td class="paramname">curIndex</td><td>The index of the current node being considered. </td></tr>
    <tr><td class="paramname">curDist</td><td>The current distance traveled. </td></tr>
    <tr><td class="paramname">curPath</td><td>An array representing the current path being constructed. </td></tr>
    <tr><td class="paramname">minDist</td><td>The minimum distance found so far. </td></tr>
    <tr><td class="paramname">path</td><td>An array to store the best path found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa5a56df7d8b0a08b6def3c21d4308577" name="aa5a56df7d8b0a08b6def3c21d4308577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a56df7d8b0a08b6def3c21d4308577">&#9670;&#160;</a></span>nodes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="structnode.html">node</a>&gt; Graph::nodes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The length of the best path found so far. The nodes in the graph. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
